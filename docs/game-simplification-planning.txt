-- sprints (whether large or small):
    -- game simplification
        <-- current. Remaining ones below aren't strictly ordered

    -- implement more games (2D? graphs?)
    -- code style cleanup
    -- hashing, TT, DB, etc

-- game simplification
    <-- The order of these simplification steps matters. Ordering given at start of each list item below

    -- generate simple .test files to validate each step. Might need a simple script for this under `./utils`
    -- (#4) combine up_stars
        <-- use this as first prototype. Need some way to undo the simplification
                may need to generalize sumgame's "undo stack"

    -- (#1) combine nimbers (using nim addition)
    -- (#3) combine integers and rationals (into one rational)

    -- (#2) switches ("Lessons in Play" p.124)
        -- allow both integers and rationals
            <-- need to change game_token_parser to support this. Just use comma to separate each endpoint?
        -- handle left <= right
            <-- no longer a switch, according to the definition
                use "The simplest number": ("Lessons in Play" p.110)
                    Algorithm described later in this file

            <-- how to actually handle this? Should switches be constructed like this, and just implement this case internally?
                Should it be required to split the switch and not play on it directly in this case?
        -- normalization: change to `a + {x | -x}` (both `a` and `x` are numbers)
        -- switches with the same gap add up to an integer:
            4|2 + -1|-3 = 1

    -- (#5) remove pairs of inverses
        -- normalized switch is its own inverse (2nd player plays on the other copy)
        -- have virtual function on game class to check trivial cases? i.e. clobber_1xn inverted boards

    <-- move ordering within sum of normalized switches: only play on the "largest" one
            need some way to do move ordering...

    -- allow toggling optimizations on/off
        <-- for testing purposes just do this with a simple CLI arg until the end of this sprint

    <-- Only DYADIC rationals are necessary for games with finite game trees (Lessons in Play p.106)
            i.e. don't need 1/3 (also note CGSuite doesn't define `.Options` for non-dyadic rationals)

    -- Need some type of runtime type information to do this
        <-- Ideally each class derived from `game` would have a unique const id accessible both as a public static field, and
            from a virtual function. But we can't use `virtual` and `static` together, so the solution is probably ugly in some way.

            This sort of "just works" (put it in the base type):

                virtual size_t get_id() final
                {
                    return typeid(*this).hash_code();
                }

            Dereferencing `this` is important, as is having `virtual` so that the types are polymorphic.
                Not sure if this is slow or not, or whether the hash is unique

            If this isn't good, we could have:

                int next_id = 0;

                template <class T>
                int obj_id()
                {
                    static int my_id = next_id++;
                    return my_id;
                }
                // also have obj_id<T>(const T*) and obj_id<T>(const T&) both implemented in terms of this 0 parameter version
                // these versions don't do anything with the pointer or reference, these are just there for template argument inference

                struct game
                {
                    virtual int obj_id() = 0;
                };

                struct clobber: public game
                {
                    int obj_id() override
                    {
                        return ::obj_id(this);
                    }
                };

            Pros: simple, should be fast on all implementations
            Cons: possibility of calling obj_id on unintended types (i.e. shared_ptr<clobber>), but could prevent this with
                    some kind of static_assert checking that T inherits from game (then call it `game_id` instead of `obj_id`)
                Probably a bad idea because `clobber` won't directly inherit from `game`, but inherits from `strip` -- more possible accidents...
            Solution: only have obj_id<T>() (no parameters) and the virtual method version, then have unit tests 
                to check that each game type's virtual obj_id() result is both different
                from every other game type, and equal to obj_id<T>() as expected.

                Good because no template type inference to cause accidents, and still have both the virtual method, and an equivalent to const static field.



To convert {X | Y} with X < Y to a number, we need to find i/2^j such that
    X < i/2^j < Y, having smallest j. If j == 0, pick i with smallest absolute value.
    Algorithm below


Number conversion algorithm to find Z for Z = {X | Y}, where X, Y, and Z are numbers and X <= Y. Assume numbers are DYADIC rationals
    1: If X < 0 and Y > 0, Z := 0

    2: If X == Y, Z := X + *
        <-- why? look at definition of CGT addition

    3: Now either (0 <= X < Y) or (X < Y <= 0). WLOG assume 1st case. (If not, solve -Z = {-Y | -X} to get 1st case, then negate Z later)

    4: Assert (0 <= X < Y)
        <-- after flipping/negating

    5: individually simplify X and Y as much as possible (this may already have been done)

    6: bring X and Y to the same denominator by multiplying one of them if denominators aren't the same
        <-- this is always easy because the denominators are powers of 2, so they will divide without remainders.
                In practice this is done with bit shifts
        <-- If the numerators now differ by 1, increase denominators by factor of 2 again

    7: Assert X and Y have same denominator D
        <-- Now everything has the same denominator, so we mostly operate on numerators from here onward. Subscript `n` refers to numerator
        The game is now Z = {Xn/D | Yn/D}

    8: For future step:
        delta := Yn - Xn

    9: Iterate j=0, j=1, ..., until Un == 1 or a solution is found
        j=0, Un := D        <-- (U == 1)
        j=1, Un := D/2      <-- (U == 1/2)
        j=2, Un := D/4      <-- (U == 1/4)
        j=3, Un := D/8      <-- (U == 1/8)
        ...
        <-- Here U == Un/D == 1/2^j and we are checking if a multiple of U occurs between X and Y and if so, we figure out which multiple it is

        at each iteration, do:
            Xn' := Xn % Un
            Yn' := Xn' + delta
        Now if Xn' < Un < Yn' , do:
            offset := Un - Xn'
            Vn := Xn + offset
            Z := Vn/D

         Now Z is the value `i/2^j` for which X < i/2^j < Y having the lowest `j`, and note that `i` is unique (assuming j >= 1; j == 0 is explained later).
            If `i` were not unique, there would be another X < i'/2^j < Y where i and i' differ by 1,
            then one of i and i' are divisible by 2, so this value would have been found for the previous j

        Note that for j=0, `i` may not be unique, meaning there's more than 1 integer between X and Y, but this algorithm will find the value corresponding
            to the smallest `i`, which is the integer with smallest absolute value

    10: If the game was negated in step 3, do Z := -Z


    <-- Rough implementation complete.
        Is there a simpler way? Are there edge cases? I think this is correct...

{5/4 | 9/4}
            == 2
{5/16 | 13/32}
            == 3/8
{1/128 | 127/128}
            == 1/2
{9/1024 | 5/128}
            == 1/32
{1033/1024 | 133/128}
            == 33/32
{-6209/1024 | -3085/512}
            == -97/16
{97/32 | 98/32}
            == 195/64
{97/32 | 99/32}
            == 49/16
{97/32 | 100/32}
            == 49/16
{97/32 | 161/32}
            == 4
{5 | 6}
            == 11/2



-- implement more games
    -- 2D games/abstractions
        -- 2D Clobber
            -- find another 2D Clobber solver to generate tests from
        -- 2D NoGo
            -- use SBHSolver to generate test cases?
    -- graph games/abstractions
        -- look at several graph games: what operations should our graphs have?
        -- col/snort (see "Lessons in Play" p.313)
        -- "Lessons in Play" rulesets appendix: cutthroat/cutthroat stars, geography, hackenbush


-- smaller tasks
    -- does CGSuite OutcomeClass rely on computing canonical form?

-- computational cost model
    <-- useful for utilizing bounds?

-- code style cleanup
    -- tweak linter configs a bit more (see docs/style.md on linter-revert branch)
    -- resolve linter errors
    -- proofread style.md

-- migrate to proper unit testing framework
    -- use google test framework?
    -- show code coverage and number of tests run
    -- allow "death tests" to test for asserts


