#include "amazons_test.h"

#include <iostream>
#include <tuple>
#include <vector>
#include <string>
#include <cassert>

#include "cgt_basics.h"
#include "test_utilities.h"
#include "amazons.h"

using namespace std;

namespace {
////////////////////////////////////////////////// test logic helpers
const string AMAZONS_PREFIX = "amazons:";

////////////////////////////////////////////////// main test functions
void test_moves_main()
{
    typedef tuple<string, vector<string>, vector<string>>
        test_case_t;

    // clang-format off
    vector<test_case_t> test_cases =
    {
        {
            "",
            {
            },
            {
            },
        },

        {
            ".",
            {
            },
            {
            },
        },

        {
            "...|.#.|...",
            {
            },
            {
            },
        },

        {
            "X",
            {
            },
            {
            },
        },

        {
            "O",
            {
            },
            {
            },
        },

        {
            "#",
            {
            },
            {
            },
        },

        {
            "X.|.#",
            {
                ".X|##",
                "#X|.#",
                "#.|X#",
                ".#|X#",
            },
            {
            },
        },

        {
            "#.|O.",
            {
            },
            {
                "#O|#.",
                "#O|.#",
                "##|.O",
                "#.|#O",
            },
        },

        {
            ".O|X.",
            {
                ".O|#X",
                "#O|.X",
                "XO|#.",
                "XO|.#",
            },
            {
                "O#|X.",
                "O.|X#",
                "#.|XO",
                ".#|XO",
            },
        },

        // cases below are generated by CGSuite 2.2-beta2
        {
            "...|X#O|...",
            {
                "X#.|.#O|...",
                "X.#|.#O|...",
                "X..|##O|...",
                "X..|.#O|#..",
                ".X#|.#O|...",
                ".X.|##O|...",
                "#X.|.#O|...",
                "...|.#O|.X#",
                "...|.#O|#X.",
                "...|##O|.X.",
                "...|##O|X..",
                "#..|.#O|X..",
                "...|.#O|X#.",
                "...|.#O|X.#",
            },
            {
                "..O|X##|...",
                "..O|X#.|..#",
                ".#O|X#.|...",
                "#.O|X#.|...",
                "...|X##|..O",
                "..#|X#.|..O",
                "...|X#.|.#O",
                "...|X#.|#.O",
                "...|X##|.O.",
                "...|X#.|.O#",
                "...|X#.|#O.",
                ".O#|X#.|...",
                ".O.|X##|...",
                "#O.|X#.|...",
            },
        },

        {
            ".X.|.O.",
            {
                "..X|.O#",
                ".#X|.O.",
                "#.X|.O.",
                "..#|.OX",
                ".#.|.OX",
                "#..|XO.",
                ".#.|XO.",
                "X#.|.O.",
                "X.#|.O.",
                "X..|#O.",
            },
            {
                ".XO|..#",
                ".XO|.#.",
                ".X#|..O",
                ".X.|.#O",
                ".X.|#.O",
                "#X.|O..",
                ".X.|O#.",
                ".X.|O.#",
                "OX.|.#.",
                "OX.|#..",
            },
        },

        {
            "..|X.|.O",
            {
                "X#|..|.O",
                "X.|.#|.O",
                "X.|#.|.O",
                "X.|..|#O",
                ".X|.#|.O",
                ".X|#.|.O",
                "#X|..|.O",
                ".#|.X|.O",
                "..|.X|#O",
                "..|#X|.O",
                "#.|.X|.O",
                "..|#.|XO",
                "#.|..|XO",
                "..|.#|XO",
            },
            {
                ".#|XO|..",
                "..|XO|.#",
                "..|XO|#.",
                "#.|XO|..",
                ".O|X#|..",
                ".O|X.|.#",
                "#O|X.|..",
                "..|X#|O.",
                "..|X.|O#",
            },
        },

        {
            ".X..X.|X..#.X|..#...|...#..|O.#..O|.O..O.",
#include "amazons_test_move_strings_big.cpp_fragment"
        },

    };
    // clang-format on

    for (const test_case_t& test_case : test_cases)
    {
        const string& board = get<0>(test_case);
        const vector<string>& exp_move_board_strings_b = get<1>(test_case);
        const vector<string>& exp_move_board_strings_w = get<2>(test_case);

        amazons g(board);

        test_moves_as_strings_for_player(&g, BLACK, exp_move_board_strings_b,
                                         AMAZONS_PREFIX);
        test_moves_as_strings_for_player(&g, WHITE, exp_move_board_strings_w,
                                         AMAZONS_PREFIX);
    }
}

void test_constructors()
{
    typedef tuple<string, int_pair, vector<int>> test_case_t;

    // clang-format off
    vector<test_case_t> test_cases =
    {
        {
            "",
            {1, 0},
            {
            },
        },

        {
            ".",
            {1, 1},
            {
                EMPTY,
            },
        },

        {
            "...|.#.|...",
            {3, 3},
            {
                EMPTY, EMPTY, EMPTY,
                EMPTY, BORDER, EMPTY,
                EMPTY, EMPTY, EMPTY,
            },
        },

        {
            "X",
            {1, 1},
            {
                BLACK,
            },
        },

        {
            "O",
            {1, 1},
            {
                WHITE,
            },
        },

        {
            "#",
            {1, 1},
            {
                BORDER,
            },
        },

        {
            "X.|.#",
            {2, 2},
            {
                BLACK, EMPTY,
                EMPTY, BORDER,
            },
        },

        {
            "#.|O.",
            {2, 2},
            {
                BORDER, EMPTY,
                WHITE, EMPTY,
            },
        },

        {
            ".O|X.",
            {2, 2},
            {
                EMPTY, WHITE,
                BLACK, EMPTY,
            },
        },

        {
            "...|X#O|...",
            {3, 3},
            {
                EMPTY, EMPTY, EMPTY, 
                BLACK, BORDER, WHITE,
                EMPTY, EMPTY, EMPTY, 
            },
        },

        {
            ".X.|.O.",
            {2, 3},
            {
                EMPTY, BLACK, EMPTY,
                EMPTY, WHITE, EMPTY,
            },
        },

        {
            "..|X.|.O",
            {3, 2},
            {
                EMPTY, EMPTY,
                BLACK, EMPTY,
                EMPTY, WHITE,
            },
        },

        {
            ".X..X.|X..#.X|..#...|...#..|O.#..O|.O..O.",
            {6, 6},
            {
                EMPTY, BLACK, EMPTY, EMPTY, BLACK, EMPTY,
                BLACK, EMPTY, EMPTY, BORDER, EMPTY, BLACK,
                EMPTY, EMPTY, BORDER, EMPTY, EMPTY, EMPTY,
                EMPTY, EMPTY, EMPTY, BORDER, EMPTY, EMPTY,
                WHITE, EMPTY, BORDER, EMPTY, EMPTY, WHITE,
                EMPTY, WHITE, EMPTY, EMPTY, WHITE, EMPTY,
            },
        },


    };
    // clang-format on

    for (const test_case_t& test_case : test_cases)
    {
        const string& board = get<0>(test_case);
        const int_pair& exp_shape = get<1>(test_case);
        const vector<int>& exp_board = get<2>(test_case);

        amazons g(board);

        assert(g.shape() == exp_shape);
        assert(g.board_const() == exp_board);
    }

    // test 0 size games
    {
        amazons g("");
        assert_num_moves(g, BLACK, 0);
        assert_num_moves(g, WHITE, 0);
    }

    // check invalid strings
    ASSERT_DID_THROW(amazons g("..|."));
    ASSERT_DID_THROW(amazons g(".A|.."));
    ASSERT_DID_THROW(amazons g(".1|.."));
}

} // namespace

//////////////////////////////////////////////////
void amazons_test_all()
{
    cout << "TODO: " << __FILE__ << endl;
    test_constructors();
    test_moves_main();
}
